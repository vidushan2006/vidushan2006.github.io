<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Private Classes — VIDU</title>

  <style>
    /* ---- page layout & visuals (self-contained) ---- */
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial; -webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}
    /* MODIFIED: Changed background from GIF to static PNG */
    body{background-image:url('assets/images/background.png'); background-size: cover; background-position: center; background-attachment: fixed; background-repeat: no-repeat; color:#eaf7ea; line-height:1.35}

    .topbar{position:fixed;left:0;right:0;top:0;z-index:120;background:linear-gradient(180deg, rgba(8,10,10,0.45), rgba(8,10,10,0.18));backdrop-filter:blur(6px) saturate(120%);border-bottom:1px solid rgba(255,255,255,0.03);box-shadow:0 6px 20px rgba(0,0,0,0.6)}
    .topbar-inner{max-width:1200px;margin:0 auto;padding:12px 20px;display:flex;justify-content:space-between;align-items:center;gap:12px}
    .left{display:flex;align-items:center;gap:14px}
    .logo-btn{display:inline-flex;align-items:center;justify-content:center;width:46px;height:46px;border-radius:6px;background:linear-gradient(180deg,#07110a,#06200b);box-shadow:0 8px 26px rgba(0,0,0,0.6);text-decoration:none}
    .nav{display:flex;gap:12px;align-items:center}
    .nav a,.nav button{color:#dfeee1;text-decoration:none;padding:8px 10px;font-weight:700;border-radius:6px;font-size:14px;background:transparent;border:0;cursor:pointer}
    .nav a:hover,.nav button:hover{transform:translateY(-2px);transition:transform .18s ease}

    .page{margin-top:100px;min-height:calc(100vh - 120px)}
    .container{max-width:1200px;margin:0 auto;padding:28px}
    .title{font-size:42px;color:#fff;text-shadow:0 8px 36px rgba(0,0,0,0.65);margin-bottom:8px;font-weight:900}
    .subtitle{color:rgba(230,240,230,0.78);margin-bottom:32px;font-size:15px}

    .tiles{display:grid;grid-template-columns:repeat(2,1fr);gap:22px;align-items:start}
    @media (min-width:900px){ .tiles{grid-template-columns:repeat(4,1fr)} }
    /* ===== MODIFIED: Centered tiles on mobile using flexbox ===== */
    @media (max-width:640px){
      .tiles{
        display: flex;
        flex-direction: column;
        align-items: center;
        gap:14px;
      }
      .card{width:100%;max-width:420px;}
    }

    /* unified card styling */
    .card{display:flex;flex-direction:column;background:linear-gradient(180deg, rgba(0,0,0,0.6), rgba(0,0,0,0.45));border-radius:10px;overflow:hidden;border:1px solid rgba(255,255,255,0.03);cursor:pointer;transition:transform .22s,box-shadow .22s;box-shadow:0 14px 30px rgba(0,0,0,0.55);min-height:300px}
    .card:hover{transform:translateY(-8px);box-shadow:0 34px 60px rgba(0,0,0,0.65)}
    .card-media{position:relative;height:220px;display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg, rgba(0,0,0,0.95), rgba(0,0,0,0.75));border-bottom:1px solid rgba(255,255,255,0.03);overflow:visible}

    /*
      Fixed neon area logic:
      - .neon-wrap has a fixed width that is wide enough to show five characters with .neon size.
      - .neon has a single fixed font-size so no JS resizing needed.
      - This ensures consistency across all thumbnails and avoids getting clipped or hidden.
    */
    .neon-wrap{
      position:relative;
      z-index:1;
      /* fixed width chosen so five typical uppercase letters will fit */
      width: 240px;
      max-width: 240px;
      display:block;
      margin:0 auto;
      overflow:hidden; /* clip glow/reflection */
      text-align:center;
      pointer-events:none;
    }

    .neon{
      font-weight:900;
      letter-spacing:6px;
      color:#00ff3a;
      text-shadow:0 0 6px rgba(0,255,120,0.95),0 0 18px rgba(0,255,120,0.45),0 18px 28px rgba(0,0,0,0.6);
      mix-blend-mode:screen;
      line-height:0.9;
      transform:translateY(-6px);
      pointer-events:none;
      user-select:none;
      white-space:nowrap;
      /* fixed font-size to guarantee 5 letters fit inside 240px neon-wrap */
      font-size:48px !important;
    }

    /* smaller variant when the neon text is intentionally shorter */
    .neon.small{
      font-size:48px !important;
      letter-spacing:4px;
    }

    .neon-reflect{
      position:relative;
      text-align:center;
      transform:scaleY(-1);
      opacity:0.22;
      filter:blur(4px);
      font-weight:900;
      color:#00ff3a;
      mix-blend-mode:screen;
      pointer-events:none;
      white-space:nowrap;
      font-size:48px !important;
      margin-top:6px;
    }

    .card-caption{padding:14px 12px 18px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));display:flex;flex-direction:column;align-items:center;gap:6px}
    .card-title{font-weight:800;color:#eaf8ea;font-size:14px;text-align:center}
    .card-type{font-size:11px;color:rgba(170,255,190,0.92);font-weight:700;text-transform:uppercase}

    .modal{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.62);z-index:300;padding:18px}
    .modal.hidden{display:none}
    .modal-box{max-width:420px;width:100%;background:linear-gradient(180deg, rgba(8,10,8,0.98), rgba(6,8,6,0.95));border-radius:12px;padding:24px;box-shadow:0 20px 60px rgba(0,0,0,0.7);color:#fff;text-align:center;position:relative}
    .modal-close{position:absolute;right:10px;top:10px;background:transparent;border:none;color:#ddd;font-size:18px;cursor:pointer}
    .modal-preview{height:120px;display:flex;align-items:center;justify-content:center;margin-bottom:12px}
    
    .pw-input, .login-input{width:100%;padding:12px 14px;border-radius:8px;border:1px solid rgba(255,255,255,0.08);background:rgba(255,255,255,0.03);color:#fff;margin-top:10px;font-size:15px;}
    .pw-actions, .login-actions{display:flex;gap:8px;margin-top:16px;justify-content:center}
    .btn{padding:10px 18px;border-radius:8px;border:none;font-weight:700;cursor:pointer;background:linear-gradient(180deg,#00c85f,#00a955);color:white;font-size:15px;transition: transform 0.18s ease;}
    .btn:hover{transform: translateY(-2px);}
    .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.04);color:#dfeee1}

    /* NEW LOGIN BUTTON STYLE */
    .login-btn-top{
        background: linear-gradient(180deg, #00b86a, #008f55);
        color: white;
        font-weight: 700;
        font-size: 14px;
        padding: 10px 16px;
        border-radius: 8px;
        border: 1px solid rgba(255,255,255,0.05);
        cursor: pointer;
        transition: transform .18s ease, box-shadow .18s ease;
        box-shadow: 0 6px 20px rgba(0,0,0,0.4);
    }
    .login-btn-top:hover{
        transform: translateY(-2px);
        box-shadow: 0 10px 25px rgba(0,0,0,0.5);
    }
    .login-btn-top:disabled {
        background: linear-gradient(180deg, #073a1e, #06200b);
        cursor: default;
        opacity: 0.8;
        transform: none;
        box-shadow: 0 6px 20px rgba(0,0,0,0.4);
    }

    .viewer{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.78);z-index:400;padding:22px}
    .viewer.hidden{display:none}
    .viewer-inner{width:100%;max-width:1100px;height:72vh;border-radius:12px;overflow:hidden;background:rgba(2,2,2,0.75);position:relative;box-shadow:0 30px 80px rgba(0,0,0,0.8);display:flex;flex-direction:column}
    .viewer-close{position:absolute;top:10px;right:10px;background:transparent;border:none;color:#ddd;font-size:20px;cursor:pointer;z-index:5}

    /* Now playing title (new): sits above the player */
    .now-playing {
      width:100%;
      padding:10px 16px;
      box-sizing:border-box;
      background:linear-gradient(180deg, rgba(0,0,0,0.3), rgba(0,0,0,0.45));
      color:#e8f7e8;
      font-weight:900;
      letter-spacing:0.6px;
      font-size:15px;
      display:flex;
      align-items:center;
      gap:12px;
      border-bottom:1px solid rgba(255,255,255,0.03);
      z-index:8;
    }
    .now-playing .label { color:rgba(200,255,190,0.85); font-weight:800; font-size:13px; opacity:0.95; text-transform:uppercase; }
    .now-playing .title { color:#fff; font-size:15px; font-weight:900; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }

    /* MODIFIED: Player wrap now takes 100% height */
    .iframe-wrap{width:100%;height:100%;display:block;background:#000;position:relative;border-bottom:1px solid rgba(255,255,255,0.03)}
    /* MODIFIED: Playlist area inside player is now hidden */
    .viewer-playlist{width:100%;height:0;display:none;box-sizing:border-box;overflow:auto;padding:0;background:linear-gradient(180deg, rgba(0,0,0,0.02), rgba(0,0,0,0.08));}
    .viewer-playlist .list-item{display:flex;align-items:center;gap:12px;padding:8px;border-radius:8px;cursor:pointer;background:transparent;transition:background .12s}
    .viewer-playlist .list-item:hover{background:rgba(255,255,255,0.02)}
    .viewer-playlist img{width:120px;height:68px;object-fit:cover;border-radius:6px;flex:0 0 120px;}
    .playlist-meta{flex:1;display:flex;flex-direction:column;gap:6px}
    .playlist-title{font-size:14px;font-weight:700;color:#fff}
    .playlist-sub{font-size:12px;color:rgba(220,220,220,0.7)}

/* ===== player UI styles (must match JS expectations) ===== */
    .vidu-player-host{position:relative;width:100%;height:100%;overflow:hidden;border-radius:8px;background:#000}
    .vidu-mount{width:100%;height:100%;background:#000}
    .vidu-mount iframe{width:100%;height:100%;border:0;display:block}

/* loading overlay (shows header.png until playback begins) */
    .vidu-loading{position:absolute;inset:0;z-index:9998;display:flex;align-items:center;justify-content:center;background-image: url('assets/images/header.png');background-repeat:no-repeat;background-position:center;background-size:cover;transition:opacity .28s ease;pointer-events:none}
    .vidu-loading.hidden{opacity:0;transform:scale(1.02);pointer-events:none;display:none}

    .vidu-controls-bg{position:absolute;left:0;right:0;bottom:0;height:64px;background:linear-gradient(180deg, rgba(0,0,0,0.55), rgba(0,0,0,0.75));pointer-events:none;z-index:9996;opacity:1;transition:opacity .22s ease, transform .22s ease;backdrop-filter:blur(4px)}
    .vidu-controls-bg.hidden{opacity:0;transform:translateY(6px)}

    .vidu-overlay{position:absolute;left:12px;right:12px;bottom:12px;z-index:9999;display:flex;gap:12px;align-items:center;padding:8px 12px;border-radius:10px;box-sizing:border-box;pointer-events:auto}
    .vidu-overlay.hidden{opacity:0;transform:translateY(6px);pointer-events:none}

    .vidu-overlay .inner-bg{position:absolute;inset:0;border-radius:10px;pointer-events:none;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));z-index:-1}

    .vidu-btn{background:rgba(255,255,255,0.06);color:#fff;padding:8px;border-radius:22px;cursor:pointer;font-weight:700;user-select:none;border:1px solid rgba(255,255,255,0.04);display:flex;align-items:center;justify-content:center;width:46px;height:46px;transition:transform .12s ease}
    .vidu-btn:active{transform:scale(.96)}

    .vidu-range{flex:1;-webkit-appearance:none;height:8px;border-radius:8px;background:rgba(255,255,255,0.06)}
    .vidu-range::-webkit-slider-thumb{-webkit-appearance:none;width:16px;height:16px;border-radius:50%;background:#39ff14;box-shadow:0 2px 8px rgba(0,0,0,0.5);border:2px solid rgba(0,0,0,0.18);margin-top:-4px}
    .vidu-range::-moz-range-thumb{width:16px;height:16px;border-radius:50%;background:#39ff14;border:2px solid rgba(0,0,0,0.18)}

    .vidu-time{min-width:90px;font-size:14px;font-weight:800;color:#cbd5ff;text-align:center;letter-spacing:1px}

    .vidu-close-btn{position:absolute;top:10px;right:10px;z-index:10002;width:36px;height:36px;padding:6px;border-radius:8px;background:rgba(0,0,0,0.46);border:1px solid rgba(255,255,255,0.06);color:#fff;display:flex;align-items:center;justify-content:center;font-weight:800;cursor:pointer;box-shadow:0 8px 24px rgba(0,0,0,0.6);transition:opacity .18s ease,transform .18s ease}
    .vidu-close-btn.hidden{opacity:0;transform:translateY(-6px);pointer-events:none}

    /* ===== NEW: Responsive player controls for small screens ===== */
    @media (max-width: 500px) {
      .vidu-overlay {
        gap: 6px; /* Reduce gap between elements */
        padding: 6px 8px; /* Reduce padding */
        left: 6px; right: 6px; bottom: 6px; /* Bring it closer to the edges */
      }
      .vidu-btn {
        width: 40px; /* Make buttons slightly smaller */
        height: 40px;
        padding: 6px;
      }
      .vidu-time {
        min-width: 65px; /* Reduce the space for time display */
        font-size: 12px; /* Smaller font for time */
        letter-spacing: 0.5px;
      }
      .vidu-controls-bg {
        height: 56px; /* Match the new smaller controls height */
      }
    }

    /* ===== NEW: Centered volume feedback (modern style) ===== */
    .vidu-volume-overlay {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
      z-index: 100010; /* above controls */
    }
    .vidu-volume-card {
      pointer-events: none;
      display: flex;
      gap: 12px;
      align-items: center;
      justify-content: center;
      min-width: 140px;
      max-width: 320px;
      padding: 12px 18px;
      border-radius: 12px;
      /* CHANGED: opaque dark background so it remains visible on white videos */
      background: linear-gradient(180deg, rgba(8,10,8,0.98), rgba(12,14,12,0.96));
      box-shadow: 0 10px 40px rgba(0,0,0,0.6), inset 0 1px 0 rgba(255,255,255,0.02);
      border: 1px solid rgba(255,255,255,0.06);
      backdrop-filter: blur(6px) saturate(120%);
      transform: scale(0.86);
      opacity: 0;
      transition: transform .22s cubic-bezier(.2,.9,.2,1), opacity .22s ease;
      color: #f4fff4;
      font-weight:900;
      letter-spacing:0.6px;
    }
    .vidu-volume-overlay.visible .vidu-volume-card {
      transform: scale(1);
      opacity: 1;
    }
    .vidu-vol-icon {
      width: 36px;
      height: 36px;
      display:flex;
      align-items:center;
      justify-content:center;
      background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.04);
      box-shadow: 0 6px 18px rgba(0,0,0,0.45);
      flex: 0 0 36px;
    }
    .vidu-vol-percent {
      font-size:18px;
      font-weight:900;
      color: #e8ffe8;
      min-width:46px;
      text-align:left;
    }
    .vidu-vol-sub { font-size:11px; color: rgba(220,255,220,0.7); font-weight:800; margin-left:6px; }
    @media (max-width:720px){
      .vidu-volume-card { min-width:120px; padding:10px 14px; }
      .vidu-vol-percent { font-size:16px; }
    }

    /* Lightweight inline styles for the playback menu (kept here so no external changes needed) */
    .vidu-playback-menu {
      position:absolute;
      z-index:100005;
      background:linear-gradient(180deg,#111,#0b0b0b);
      border:1px solid rgba(255,255,255,0.06);
      border-radius:8px;
      padding:6px;
      box-shadow:0 12px 30px rgba(0,0,0,0.6);
      min-width:88px;
    }
    .vidu-playback-item {
      display:block;
      padding:8px 10px;
      color:#e6f7e6;
      text-align:center;
      font-weight:800;
      cursor:pointer;
      border-radius:6px;
      margin:4px 0;
      background:transparent;
      font-size:13px;
    }
    .vidu-playback-item:hover { background:rgba(255,255,255,0.03); }
    .vidu-playback-item.active { background:rgba(57,255,20,0.12); color:#dfffd6; }

    /* ===== NEW: Playlist full-screen popup UI ===== */
    .playlist-popup {
      position: fixed;
      inset: 12px;
      z-index: 600;
      display: none;
      align-items: center;
      justify-content: center;
      pointer-events: auto;
    }
    .playlist-popup.visible { display:flex; }
    .playlist-popup-inner {
      width: 100%;
      height: 100%;
      background: linear-gradient(180deg, rgba(8,10,8,0.98), rgba(6,8,6,0.95));
      border-radius: 14px;
      box-shadow: 0 40px 120px rgba(0,0,0,0.8);
      padding: 18px;
      box-sizing: border-box;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }
    .playlist-popup-header {
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      margin-bottom:12px;
    }
    .playlist-popup-count {
      font-weight:900;
      color:#eaf7ea;
      background: linear-gradient(90deg, rgba(0,255,140,0.08), rgba(255,255,255,0.01));
      padding:8px 12px;
      border-radius: 12px;
      font-size: 14px;
      box-shadow: 0 6px 22px rgba(0,0,0,0.6);
      border: 1px solid rgba(255,255,255,0.03);
    }
    .playlist-popup-title {
      font-size:18px;
      font-weight:900;
      color:#fff;
      flex:1;
      text-align:left;
      margin-left:16px;
    }
    .playlist-popup-close {
      border:0;
      background:transparent;
      color:#ddd;
      font-weight:800;
      font-size:20px;
      cursor:pointer;
    }
    .playlist-popup-body {
      overflow:auto;
      border-radius:10px;
      padding:8px;
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.01));
      flex:1;
    }
    .playlist-item {
      display:flex;
      gap:12px;
      align-items:center;
      padding:12px;
      border-radius:10px;
      transition: background .12s, transform .08s;
      cursor:pointer;
      margin-bottom:8px;
      background:transparent;
    }
    .playlist-item:hover { background: rgba(255,255,255,0.02); transform: translateY(-2px); }
    /* REMOVED IMG STYLING, REPLACED WITH NEW NUMBER THUMBNAIL STYLE */
    .playlist-item-num-thumb {
      width: 140px;
      height: 78px;
      flex: 0 0 140px;
      border-radius: 8px;
      background: #000;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 42px;
      font-weight: 900;
      color: #00ff3a;
      text-shadow: 0 0 6px rgba(0,255,120,0.95), 0 0 18px rgba(0,255,120,0.45);
      user-select: none;
    }
    .playlist-item .meta { display:flex; flex-direction:column; gap:6px; }
    .playlist-item .meta .t { font-weight:800; color:#fff; font-size:14px; }
    .playlist-item .meta .s { color: rgba(220,220,220,0.75); font-size:12px; }

    /* ===== NEW: Playlist Loading Indicator Styles ===== */
    .playlist-loading-indicator {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100%;
      gap: 18px;
      user-select: none;
      text-align: center;
    }
    .playlist-loading-indicator .spinner {
      width: 48px;
      height: 48px;
      border: 5px solid rgba(255, 255, 255, 0.12);
      border-top-color: #00ff8a;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    .playlist-loading-indicator .loading-text {
      font-size: 18px;
      font-weight: 800;
      color: rgba(230, 240, 230, 0.85);
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* ===== NEW: Loading popup with rounded progress bar ===== */
    .loading-popup {
      position: fixed;
      inset: 0;
      z-index: 800;
      display:none;
      align-items:center;
      justify-content:center;
      pointer-events: none;
    }
    .loading-popup.visible { display:flex; pointer-events:auto; }
    .loading-card {
      width: min(540px, 90%);
      background: linear-gradient(180deg, rgba(10,12,10,0.95), rgba(6,8,6,0.96));
      padding: 18px;
      border-radius: 12px;
      box-shadow: 0 30px 80px rgba(0,0,0,0.7);
      text-align:center;
      color:#eaf7ea;
      border: 1px solid rgba(255,255,255,0.03);
    }
    .loading-label { font-weight:900; margin-bottom:12px; font-size:16px; }
    .loading-bar-wrap { background: rgba(255,255,255,0.04); border-radius: 999px; height: 14px; overflow:hidden; }
    .loading-bar { height:100%; width:0%; border-radius:999px; background: linear-gradient(90deg,#00ff8a,#00b86a); transition: width 2s linear; }

    .copyright{text-align:center;margin-top:28px;color:rgba(255,255,255,0.85);font-size:13px}
  </style>
</head>
<body>
  <header class="topbar" role="banner">
    <div class="topbar-inner">
      <div class="left">
        <a class="logo-btn" href="index.html" title="Home" aria-label="Home">
          <svg width="30" height="30" viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false">
            <defs><linearGradient id="gV" x1="0" x2="1" y1="0" y2="1"><stop offset="0" stop-color="#00ff55"/><stop offset="1" stop-color="#00b86a"/></linearGradient></defs>
            <rect x="4" y="4" width="56" height="56" rx="8" fill="#07120b"/>
            <path d="M16 16 L32 46 L48 16" stroke="url(#gV)" stroke-width="5" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </a>
        <nav class="nav" aria-label="Main navigation">
          <a href="index.html">🏠 Home</a>
          <a href="about.html">ℹ️ About</a>
          <button id="nav-private"></button>
        </nav>
      </div>
      <button id="login-btn-top" class="login-btn-top">🔑 Login</button>
    </div>
  </header>

  <main class="page" role="main">
    <div class="container">
      <h1 class="title">Private Classes</h1>
      <p class="subtitle">To access Login with a account that has permission(or ask vidu to give permission)</p>

      <section id="tiles" class="tiles" aria-live="polite"></section>
      <div class="copyright">© VIDU. All rights reserved.</div>
    </div>
  </main>

  <div id="login-modal" class="modal hidden" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="modal-box" role="document">
      <button class="modal-close" id="login-close" aria-label="Close">✕</button>
      <h3 style="color:#dfeee1; font-weight:800; margin-bottom:16px; font-size: 22px;">🗝️ Login</h3>
      <input id="login-username" class="login-input" type="text" placeholder="Username" autocomplete="username" />
      <input id="login-password" class="login-input" type="password" placeholder="Password" autocomplete="current-password" />
      <div class="login-actions">
        <button id="login-submit" class="btn">Login</button>
      </div>
      <p id="login-error" style="color:#ff8080;margin-top:12px;min-height:18px;"></p>
    </div>
  </div>

  <div id="access-modal" class="modal hidden" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="modal-box" role="document">
        <button class="modal-close" id="access-close" aria-label="Close">✕</button>
        <p style="font-size: 20px; font-weight: 700; color: #eaf7ea; margin: 20px 0;">🔒 Login to access these</p>
        <div class="pw-actions">
            <button id="access-request-btn" class="btn">Request Access</button>
        </div>
    </div>
  </div>

  <div id="no-access-modal" class="modal hidden" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="modal-box" role="document">
      <button class="modal-close" id="no-access-close" aria-label="Close">✕</button>
      <p style="font-size: 20px; font-weight: 700; color: #eaf7ea; margin: 20px 0;">🔒 You don't have access to this</p>
      <div class="pw-actions">
          <button id="no-access-request-btn" class="btn">Request Access</button>
      </div>
    </div>
  </div>

  <div id="pw-modal" class="modal hidden" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="modal-box" role="document">
      <button class="modal-close" id="pw-close" aria-label="Close">✕</button>
      <div class="modal-preview" id="modal-preview"></div>
      <h3 id="pw-title" style="color:#dfeee1;font-weight:800;margin-bottom:6px;">Enter password</h3>
      <input id="pw-input" class="pw-input" type="password" placeholder="Password" autocomplete="off" />
      <div class="pw-actions">
        <button id="pw-submit" class="btn">Unlock</button>
        <button id="pw-cancel" class="btn ghost">Cancel</button>
      </div>
      <p id="pw-error" style="color:#ff8080;margin-top:10px;min-height:18px;"></p>
    </div>
  </div>

  <div id="viewer" class="viewer hidden" aria-hidden="true">
    <div class="viewer-inner">
      <button id="viewer-close" class="viewer-close" aria-label="Close viewer">✕</button>

      <div class="now-playing" aria-hidden="false">
        <div class="label">Now playing</div>
        <div class="title" id="now-playing-title">—</div>
      </div>

      <div id="iframe-wrap" class="iframe-wrap"></div>

      <div id="viewer-playlist" class="viewer-playlist" aria-live="polite"></div>
    </div>
  </div>

  <div id="playlist-popup" class="playlist-popup" aria-hidden="true">
    <div class="playlist-popup-inner" role="dialog" aria-modal="true" aria-label="Playlist">
      <div class="playlist-popup-header">
        <div class="playlist-popup-count" id="playlist-count">0 Videos</div>
        <div class="playlist-popup-title" id="playlist-popup-title">Playlist</div>
        <button class="playlist-popup-close" id="playlist-popup-close" aria-label="Close playlist">✕</button>
      </div>
      <div class="playlist-popup-body" id="playlist-popup-body" tabindex="0"></div>
    </div>
  </div>

  <div id="loading-popup" class="loading-popup" aria-hidden="true">
    <div class="loading-card" role="status" aria-live="polite">
      <div class="loading-label">Initializing VIDU Player</div>
      <div class="loading-bar-wrap" aria-hidden="false">
        <div id="loading-bar" class="loading-bar" style="width:0%"></div>
      </div>
    </div>
  </div>

  <div id="js-fail-note" style="display:none;position:fixed;right:14px;bottom:14px;background:rgba(255,80,80,0.12);color:#ffdede;border:1px solid rgba(255,80,80,0.2);padding:8px 12px;border-radius:8px;font-size:13px;z-index:9999">Some features may be unavailable — enable JavaScript.</div>

  <script>
  (function(){
    /* ---------- configuration ---------- */
    const YT_API_KEY = 'AIzaSyB8UVKOZOnUnYdqbFGOtlg6BPfR9HpD35c'; // keep your key here (used for playlist fetching)
    const YT_API_LOAD_TIMEOUT = 18000; // ms - how long to wait for YT API before showing error

    /* ===== MODIFIED: User Permission System ===== */
    // Define users, their passwords, and what content they can access by its title.
    const userPermissions = {
      'vidu': {
        password: 'vidu123',
        access: ['PHONK', 'TEST', 'ICT', 'ET Speed Revision', 'ET Theory'] // 'vidu' can access everything
      },
      'Imal': {
        password: '123',
        access: ['ET Speed Revision', 'ET Theory'] // 'Imal' can only access the two ET playlists
      },
      'user': {
        password: 'password',
        access: ['PHONK', 'TEST'] // 'user' can only access the two single videos
      }
    };
    let currentUser = null; // Replaces the old 'isLoggedIn' flag. Stores the logged-in user's data.

    // MODIFIED: Added global variable to remember volume across videos.
    let globalLastVolume = 100;

    /* ---------- sample items (unchanged layout) ---------- */
    const items = [
      { type: 'video', title: 'PHONK', idB64: btoa("m0fM0rBN7cQ"), passB64: btoa("")},
      { type: 'video', title: 'TEST', idB64: btoa("Lexok6H2c2s"), passB64: btoa("")},
      { type: 'playlist', title: 'ICT', idB64: btoa("PL9zX0VbNmKiFlxda5PCTn4_hA_7iKjEaA&si=9nF_7qpAzKt4cYZd"), passB64: btoa("6002vidu") },
      { type: 'playlist', title: 'ET Speed Revision', idB64: btoa("PL9zX0VbNmKiF-Q7bnmM1v_DrT3_Ol-Of5&si=efJHPzWR-kZcGwYw"), passB64: btoa("amilaet") },
      { type: 'playlist', title: 'ET Theory', idB64: btoa("PL9zX0VbNmKiFKQ388JcZsq18mlyIe7BeI&si=cn4rwat6rsqC8kH_"), passB64: btoa("amilaet") }
      
    ];

    /* ---------- utilities ---------- */
    function escapeHtml(s){ return String(s || '').replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }
    function neonTextFor(title){
      if(!title) return '';
      const main = (title||'').split(/[\u2013\u2014\-+]/)[0].trim();
      const words = main.split(/\s+/);
      if(words.length === 1) return words[0].toUpperCase().slice(0, 6);
      return words[0].toUpperCase();
    }
    function normalizeIdFromB64(idB64){
      try { return atob(idB64 || '').split('&')[0]; } catch(e){ console.warn('Invalid idB64', idB64, e); return ''; }
    }

    /* ---------- render tiles (neon-wrap fixed-size approach) ---------- */
    function buildTiles(){
      const tiles = document.getElementById('tiles');
      tiles.innerHTML = '';
      items.forEach((it, idx)=>{
        const card = document.createElement('button');
        card.className = 'card';
        card.type = 'button';
        card.setAttribute('data-idx', idx);
        card.setAttribute('aria-label', it.title + ' ' + it.type);

        const neon = neonTextFor(it.title);
        const small = neon.length > 6 ? ' small' : '';
        card.innerHTML = `
          <div class="card-media" role="img" aria-label="${escapeHtml(it.title)} thumbnail">
            <div class="neon-wrap">
              <div class="neon${small}">${escapeHtml(neon)}</div>
              <div class="neon-reflect${small}" aria-hidden="true">${escapeHtml(neon)}</div>
            </div>
          </div>
          <div class="card-caption">
            <div class="card-title">${escapeHtml(it.title)}</div>
            <div class="card-type">${escapeHtml(it.type)}</div>
          </div>
        `;
        // Click handler now checks type: open playlist-popup or viewer.
        card.addEventListener('click', ()=> handleTileClick(it));
        tiles.appendChild(card);
      });
    }

    /* ---------- modal helpers ---------- */
    function showModal(el){ el.classList.remove('hidden'); el.setAttribute('aria-hidden','false'); document.body.style.overflow='hidden'; }
    function closeModal(el){ el.classList.add('hidden'); el.setAttribute('aria-hidden','true'); document.body.style.overflow=''; }

    /* ---------- NEW: Playlist popup helpers & state ---------- */
    let lastOpenedPlaylistItem = null; // remember playlist so we can re-open after closing player
    const playlistCache = {}; // <<< In-memory cache for playlists

    const playlistPopup = document.getElementById('playlist-popup');
    const playlistBody = document.getElementById('playlist-popup-body');
    const playlistCountEl = document.getElementById('playlist-count');
    const playlistTitleEl = document.getElementById('playlist-popup-title');
    const playlistCloseBtn = document.getElementById('playlist-popup-close');
    const loadingPopup = document.getElementById('loading-popup');
    const loadingBar = document.getElementById('loading-bar');

    function renderPlaylistBody(videos) {
      playlistBody.innerHTML = '';
      playlistCountEl.textContent = `${videos.length} Videos`;

      if (!videos.length) {
        playlistBody.innerHTML = `<div style="padding:18px;color:#ffdede">No videos found in this playlist.</div>`;
        return;
      }

      videos.forEach((v, index) => {
        const node = document.createElement('div');
        node.className = 'playlist-item';
        // MODIFIED: Replaced <img> with a styled div containing the video number.
        node.innerHTML = `
          <div class="playlist-item-num-thumb">${index + 1}</div>
          <div class="meta">
            <div class="t">${escapeHtml(v.title)}</div>
            <div class="s">Click to play</div>
          </div>
        `;
        node.tabIndex = 0;

        function clickHandler() {
          closePlaylistPopup();
          showLoadingPopupThenPlay(v);
        }
        node.addEventListener('click', clickHandler);
        node.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            clickHandler();
          }
        });
        playlistBody.appendChild(node);
      });
      playlistBody.scrollTop = 0;
    }

    function openPlaylistPopup(item) {
      // Set the title first, as it's always available.
      playlistTitleEl.textContent = item.title || 'Playlist';
      lastOpenedPlaylistItem = item; // Keep track of the current item.

      const playlistId = normalizeIdFromB64(item.idB64 || '');

      // --- ROBUST CACHING LOGIC ---
      if (playlistCache[playlistId]) {
        // CACHE HIT: Prepare the content BEFORE showing the popup for an instant display.
        renderPlaylistBody(playlistCache[playlistId]);
        
        // Now show the fully prepared popup.
        playlistPopup.classList.add('visible');
        playlistPopup.setAttribute('aria-hidden', 'false');
        document.body.style.overflow = 'hidden';
      } else {
        // CACHE MISS: Prepare the "loading" content BEFORE showing.
        playlistCountEl.textContent = 'Loading...';
        // MODIFIED: Replaced the simple text with a centered spinner and larger text.
        playlistBody.innerHTML = `
          <div class="playlist-loading-indicator">
            <div class="spinner"></div>
            <div class="loading-text">Initializing VIDU Fetcher...</div>
          </div>
        `;

        // Now show the popup in its loading state.
        playlistPopup.classList.add('visible');
        playlistPopup.setAttribute('aria-hidden', 'false');
        document.body.style.overflow = 'hidden';

        // Start fetching the data asynchronously.
        (async () => {
          try {
            const videos = await fetchPlaylistVideos(playlistId);
            playlistCache[playlistId] = videos; // Store result in cache

            // Check if the user is still looking at this specific playlist popup.
            // This prevents a race condition if they close it quickly.
            if (lastOpenedPlaylistItem === item && playlistPopup.classList.contains('visible')) {
              renderPlaylistBody(videos);
            }
          } catch (err) {
            console.error("Playlist fetch error:", err);
            if (lastOpenedPlaylistItem === item && playlistPopup.classList.contains('visible')) {
              playlistBody.innerHTML = `<div style="padding:18px;color:#ffdede">Failed to load playlist: ${escapeHtml(err && err.message ? err.message : String(err))}</div>`;
              playlistCountEl.textContent = '0 Videos';
            }
          }
        })();
      }
    }

    function closePlaylistPopup(){
      playlistPopup.classList.remove('visible');
      playlistPopup.setAttribute('aria-hidden','true');
      document.body.style.overflow = '';
    }

    playlistCloseBtn.addEventListener('click', ()=> closePlaylistPopup());
    playlistPopup.addEventListener('click', (e)=> { if(e.target === playlistPopup) closePlaylistPopup(); });

    function showLoadingPopupThenPlay(v){
      // show loading popup with bar filling for 2 seconds, then open player
      loadingBar.style.transition = 'none';
      loadingBar.style.width = '0%';
      loadingPopup.classList.add('visible');
      loadingPopup.setAttribute('aria-hidden','false');
      document.body.style.overflow = 'hidden';
      // ensure transition kicks in
      setTimeout(()=>{
        loadingBar.style.transition = 'width 2s linear';
        loadingBar.style.width = '100%';
      }, 20);
      setTimeout(()=>{
        // hide loading, then open viewer with this video
        loadingPopup.classList.remove('visible');
        loadingPopup.setAttribute('aria-hidden','true');
        loadingBar.style.transition = 'none';
        loadingBar.style.width = '0%';
        document.body.style.overflow = '';
        // construct a video item and open viewer
        const videoItem = { type: 'video', title: v.title, idB64: btoa(v.videoId) };
        openViewer(videoItem);
      }, 2000); // exactly 2 seconds as requested
    }

    /* ===== MODIFIED: Updated click handler with permission checks ===== */
    function handleTileClick(item) {
        if (currentUser) {
            // User is logged in, check if they have permission for this item.
            // We check if the item's title is in the user's 'access' array.
            if (currentUser.permissions.includes(item.title)) {
                // SUCCESS: User has access.
                if (item && item.type === 'playlist') {
                    openPlaylistPopup(item);
                } else {
                    lastOpenedPlaylistItem = null;
                    openViewer(item);
                }
            } else {
                // FAIL: User is logged in but does not have permission.
                showModal(noAccessModal);
            }
        } else {
            // FAIL: User is not logged in at all.
            showModal(accessModal);
        }
    }

    /* ---------- (Original) password modal - kept for integrity ---------- */
    let currentItem = null;
    const pwModal = document.getElementById('pw-modal');
    const pwTitleEl = document.getElementById('pw-title');
    const pwInput = document.getElementById('pw-input');
    const pwSubmit = document.getElementById('pw-submit');
    const pwCancel = document.getElementById('pw-cancel');
    const pwClose = document.getElementById('pw-close');
    const pwError = document.getElementById('pw-error');
    const modalPreview = document.getElementById('modal-preview');

    function openPasswordModal(item){
      try{
        const decoded = item && typeof item.passB64 === 'string' ? atob(item.passB64) : '';
        if(!decoded || decoded.trim() === ''){
          openViewer(item);
          return;
        }
      }catch(e){
        console.warn('passB64 decode failed, showing modal', e);
      }
      currentItem = item;
      pwError.textContent = '';
      pwInput.value = '';
      pwTitleEl.textContent = `Unlock: ${item.title}`;
      modalPreview.innerHTML = `<div class="neon" style="font-size:56px;">${escapeHtml(neonTextFor(item.title))}</div>`;
      showModal(pwModal);
      setTimeout(()=> pwInput.focus(), 120);
    }

    function verifyPassword(){
      if(!currentItem) return;
      const entered = (pwInput.value || '').trim();
      try{
        const expected = atob(currentItem.passB64 || '');
        if(entered === expected){
          closeModal(pwModal);
          openViewer(currentItem);
        } else {
          pwError.textContent = 'Incorrect password. Try again.';
          pwInput.select();
        }
      }catch(e){
        pwError.textContent = 'Error checking password.';
      }
    }

    pwSubmit.addEventListener('click', verifyPassword);
    pwInput.addEventListener('keydown', (e)=>{ if(e.key==='Enter') verifyPassword(); });
    pwCancel.addEventListener('click', ()=> closeModal(pwModal));
    pwClose.addEventListener('click', ()=> closeModal(pwModal));
    pwModal.addEventListener('click', (e)=> { if(e.target === pwModal) closeModal(pwModal); });

    /* ---------- YT API loader (no iframe fallback) ---------- */
    function loadYTApi(){
      if(window.YT && window.YT.Player) return Promise.resolve();
      if(window._vidu_loading_yt_promise) return window._vidu_loading_yt_promise;
      window._vidu_loading_yt_promise = new Promise((resolve, reject)=>{
        const s = document.createElement('script');
        s.src = 'https://www.youtube.com/iframe_api';
        s.async = true;
        s.onerror = () => reject(new Error('YT API failed to load (network error)'));
        document.head.appendChild(s);
        let finished = false;
        window.onYouTubeIframeAPIReady = function(){
          if(finished) return;
          finished = true;
          resolve();
        };
        const poll = setInterval(()=> {
          if(window.YT && window.YT.Player){
            if(finished) return;
            finished = true;
            clearInterval(poll);
            resolve();
          }
        }, 200);
        setTimeout(()=> {
          if(finished) return;
          finished = true;
          clearInterval(poll);
          reject(new Error('YT API timed out'));
        }, YT_API_LOAD_TIMEOUT);
      });
      return window._vidu_loading_yt_promise;
    }

    function resetYTLoader(){
      try{ delete window._vidu_loading_yt_promise; }catch(e){}
      try{ delete window.onYouTubeIframeAPIReady; }catch(e){}
    }

    /* ---------- Player module (advanced-player only) ---------- */
    (function playerModule(){
      if(window.__viduPlayerLoaded) return;
      window.__viduPlayerLoaded = true;

      const state = {
        player: null,
        updateInterval: null,
        keyHandler: null,
        mo: null,
        host: null,
        mount: null,
        fsListener: null,
        fsResizeHandler: null,
        inactivityTimer: null,
        lastActivity: Date.now(),
        desiredPlaying: null,
        lastVolume: 100,
        volumeHideTimer: null
      };

      function pad2(n){ n = Math.max(0, Math.floor(n||0)); return (n < 10 ? '0' + n : String(n)); }
      function fmtTime(s){ s = Math.max(0, Math.floor(s||0)); const h = Math.floor(s/3600); const m = Math.floor((s%3600)/60); const sec = s%60; return pad2(h) + ' : ' + pad2(m) + ' : ' + pad2(sec); }
      function playSVG(){ return `<svg viewBox="0 0 24 24" width="18" height="18" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M6 4.5v15l12-7.5L6 4.5z" fill="#fff"/></svg>`; }
      function pauseSVG(){ return `<svg viewBox="0 0 24 24" width="18" height="18" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="5" y="4" width="4" height="16" rx="1.2" fill="#fff"/><rect x="15" y="4" width="4" height="16" rx="1.2" fill="#fff"/></svg>`; }
      function gearSVG(){ return `<svg viewBox="0 0 24 24" width="18" height="18" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M12 15.5A3.5 3.5 0 1 0 12 8.5a3.5 3.5 0 0 0 0 7zm7.4-3.5c0-.4-.03-.78-.09-1.15l1.86-1.44a.5.5 0 0 0 .12-.65l-1.76-3.05a.5.5 0 0 0-.6-.22l-2.2.88a7.72 7.72 0 0 0-1.9-1.1l-.33-2.33A.5.5 0 0 0 13.9 2h-3.8a.5.5 0 0 0-.5.42l-.33 2.33c-.69.25-1.35.6-1.95 1.02l-2.2-.88a.5.5 0 0 0-.6.22L2.7 6.96a.5.5 0 0 0 .12.65l1.86 1.44c-.06.37-.09.75-.09 1.15s.03.78.09 1.15L2.82 14.95a.5.5 0 0 0-.12.65l1.76 3.05c.14.24.4.34.64.28l2.2-.88c.6.42 1.26.77 1.95 1.02l.33 2.33c.03.25.25.42.5.42h3.8c.25 0 .47-.17.5-.42l.33-2.33c.69-.25 1.35-.6 1.95-1.02l2.2.88c.24.09.5-.04.64-.28l1.76-3.05a.5.5 0 0 0-.12-.65l-1.86-1.44c.06-.37.09-.75.09-1.15z" fill="#fff"/></svg>`; }
      // NEW: SVG icons for fullscreen button for better quality and UX
      function enterFullscreenSVG() { return `<svg viewBox="0 0 24 24" width="20" height="20" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M15 3h6v6m-2-4L11 13m-2 8H3v-6m2 4l8-8" stroke="#fff" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/></svg>`; }
      function exitFullscreenSVG() { return `<svg viewBox="0 0 24 24" width="20" height="20" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3 9V3h6m4 2L5 13m16-2v6h-6m-2-4l8 8" stroke="#fff" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/></svg>`; }

      function createHostElementsIn(mountRootId){
        const wrap = document.getElementById(mountRootId);
        if(!wrap) throw new Error('#' + mountRootId + ' not found');
        const prev = wrap.querySelector('.vidu-player-host');
        if(prev) prev.remove();
        const host = document.createElement('div'); host.className = 'vidu-player-host';
        const mount = document.createElement('div'); mount.className = 'vidu-mount'; mount.id = 'vidu_mount_'+Math.floor(Math.random()*1e6);
        mount.style.height = '100%'; mount.style.background = '#000';
        host.appendChild(mount);

        // Loading overlay - show header.png until playback begins
        const loadingDiv = document.createElement('div');
        loadingDiv.className = 'vidu-loading';
        loadingDiv.id = 'vidu_loading';
        host.appendChild(loadingDiv);

        const ctrlBg = document.createElement('div'); ctrlBg.className = 'vidu-controls-bg'; host.appendChild(ctrlBg);
        const overlay = document.createElement('div'); overlay.className = 'vidu-overlay';
        overlay.innerHTML = `
          <div class="inner-bg" aria-hidden="true"></div>
          <button class="vidu-btn" id="vidu_playbtn">${playSVG()}</button>
          <div class="vidu-time" id="vidu_cur">` + fmtTime(0) + `</div>
          <input id="vidu_seek" class="vidu-range" type="range" min="0" max="100" step="0.1" value="0" />
          <div class="vidu-time" id="vidu_dur">` + fmtTime(0) + `</div>
          <button class="vidu-btn" id="vidu_playbackbtn" title="Playback speed" aria-label="Playback speed">` + gearSVG() + `</button>
          <button class="vidu-btn" id="vidu_fullbtn" title="Toggle fullscreen" aria-label="Toggle fullscreen">${enterFullscreenSVG()}</button>
        `;
        host.appendChild(overlay);

        // Close button
        const closeBtn = document.createElement('button');
        closeBtn.className = 'vidu-close-btn'; closeBtn.id = 'vidu_closebtn'; closeBtn.title = 'Close'; closeBtn.type = 'button'; closeBtn.innerHTML = '✕';
        closeBtn.addEventListener('click', ()=> {
          try{
            const v = document.getElementById('viewer'); if(v){ v.classList.add('hidden'); v.setAttribute('aria-hidden','true'); }
            if(window.destroyViduPlayer) window.destroyViduPlayer();
            const wrap = document.getElementById(mountRootId); if(wrap) wrap.innerHTML = '';
            document.body.style.overflow = '';
          }catch(e){ console.warn('closeBtn error', e); }
        });
        host.appendChild(closeBtn);

        // -------- Create fresh volume overlay (clean, modern) --------
        const volWrap = document.createElement('div');
        volWrap.className = 'vidu-volume-overlay';
        volWrap.setAttribute('aria-hidden','true');
        volWrap.innerHTML = `
          <div class="vidu-volume-card" role="status" aria-live="polite">
            <div class="vidu-vol-icon" id="vidu_vol_icon">
              </div>
            <div style="display:flex;flex-direction:column;align-items:flex-start;justify-content:center">
              <div class="vidu-vol-percent" id="vidu_vol_pct">100%</div>
              <div class="vidu-vol-sub" id="vidu_vol_sub">Volume</div>
            </div>
          </div>
        `;
        // ensure overlay sits above content and doesn't block pointer events
        host.appendChild(volWrap);

        wrap.appendChild(host);
        return { host, mount, overlay, ctrlBg, closeBtn, loadingDiv, volWrap };
      }

      function disableIframeClicks(host){
        try{
          const ifr = host.querySelector('iframe');
          if(ifr){
            ifr.style.pointerEvents = 'none';
            ifr.setAttribute('allow','autoplay; encrypted-media; fullscreen');
            ifr.setAttribute('allowfullscreen','');
            ifr.setAttribute('tabindex','-1');
          }
        }catch(e){ console.warn('disableIframeClicks', e); }
      }

      async function createYTPlayer(videoId, mountRootId='player-wrap'){
        // ensure YT API loaded (throws if not)
        await loadYTApi();

        // create host + mount now that API is available
        const { host, mount, overlay, ctrlBg, closeBtn, loadingDiv, volWrap } = createHostElementsIn(mountRootId);
        state.host = host; state.mount = mount;

        // saved styles container so we can restore when exit fullscreen
        const saved = { stored:false, host:{}, mount:{}, iframe:{} };

        const playBtn = overlay.querySelector('#vidu_playbtn');
        const curEl = overlay.querySelector('#vidu_cur');
        const durEl = overlay.querySelector('#vidu_dur');
        const seekEl = overlay.querySelector('#vidu_seek');
        const playbackBtn = overlay.querySelector('#vidu_playbackbtn');
        const fullBtn = overlay.querySelector('#vidu_fullbtn');

        // -------- volume overlay helpers (fresh implementation) --------
        function renderVolIcon(vol){
          // simple speaker icon with waves; muted when vol === 0
          const muted = (vol === 0);
          if(muted){
            return `<svg viewBox="0 0 24 24" width="20" height="20" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M11 6L6 10H3v4h3l5 4V6z" fill="#fff" opacity="0.96"/><path d="M19 9l-1.4-1.4L16 9.2 17.4 10.6 19 9z" fill="#fff"/><line x1="21" y1="3" x2="3" y2="21" stroke="#ff7f7f" stroke-width="1.6" stroke-linecap="round"/></svg>`;
          } else {
            return `<svg viewBox="0 0 24 24" width="20" height="20" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M11 6L6 10H3v4h3l5 4V6z" fill="#fff" opacity="0.96"/><path d="M16.5 7.5c.9.9 1.5 2.1 1.5 3.5s-.6 2.6-1.5 3.5" stroke="#bfffbf" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
          }
        }

        function showVolumeOverlay(volume){
          try{
            if(!volWrap) return;
            const pct = Math.max(0, Math.min(100, Math.round(Number(volume)||0)));
            const pctEl = volWrap.querySelector('#vidu_vol_pct');
            const iconEl = volWrap.querySelector('#vidu_vol_icon');
            const card = volWrap.querySelector('.vidu-volume-card');
            if(pctEl) pctEl.textContent = pct + '%';
            if(iconEl) iconEl.innerHTML = renderVolIcon(pct);
            volWrap.classList.add('visible');
            volWrap.setAttribute('aria-hidden','false');

            // clear previous timer
            if(state.volumeHideTimer) { clearTimeout(state.volumeHideTimer); state.volumeHideTimer = null; }

            // hide after 3s
            state.volumeHideTimer = setTimeout(()=>{
              try{
                volWrap.classList.remove('visible');
                volWrap.setAttribute('aria-hidden','true');
                state.volumeHideTimer = null;
              }catch(e){}
            }, 3000);
          }catch(e){ console.warn('showVolumeOverlay err', e); }
        }

        function hideVolumeOverlayImmediate(){
          try{
            if(state.volumeHideTimer){ clearTimeout(state.volumeHideTimer); state.volumeHideTimer = null; }
            if(volWrap){
              volWrap.classList.remove('visible');
              volWrap.setAttribute('aria-hidden','true');
            }
          }catch(e){}
        }

        function getFullscreenElement(){
          return document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement || null;
        }

        const savedResizeHandler = ()=> {
          try{
            const curFS = document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement || null;
            const stillOurFS = !!(curFS && (curFS === host || host.contains(curFS) || (curFS.contains && curFS.contains(host))));
            if(stillOurFS){
              try{ host.style.width = window.innerWidth + 'px'; host.style.height = window.innerHeight + 'px'; }catch(e){}
              try{ mount.style.height = window.innerHeight + 'px'; }catch(e){}
              try{ const ifr = host.querySelector('iframe'); if(ifr) ifr.style.height = window.innerHeight + 'px'; }catch(e){}
            }
          }catch(e){}
        };

        function toggleFullscreen(){
          const fs = getFullscreenElement();
          if(fs === host){
            const exit = document.exitFullscreen || document.webkitExitFullscreen || document.mozCancelFullScreen || document.msExitFullscreen;
            if(exit) exit.call(document);
          } else {
            const req = host.requestFullscreen || host.webkitRequestFullscreen || host.mozRequestFullScreen || host.msRequestFullscreen;
            if(req) req.call(host);
          }
        }
        fullBtn.addEventListener('click', toggleFullscreen);

        // Playback menu implementation
        let playbackMenu = null;
        let menuOpen = false;

        function closePlaybackMenu(){
          if(!playbackMenu) return;
          try{ playbackMenu.remove(); }catch(e){}
          playbackMenu = null;
          menuOpen = false;
          document.removeEventListener('click', docClickCloseHandler);
        }
        function docClickCloseHandler(e){
          if(!playbackMenu) return;
          if(playbackMenu.contains(e.target) || playbackBtn.contains(e.target)) return;
          closePlaybackMenu();
        }

        function formatRateLabel(r){ return (Math.round(r*100)/100) + '×'; }

        function openPlaybackMenu(){
          if(menuOpen){ closePlaybackMenu(); return; }
          playbackMenu = document.createElement('div');
          playbackMenu.className = 'vidu-playback-menu';
          playbackMenu.setAttribute('role','menu');
          playbackMenu.setAttribute('aria-label','Playback speed menu');

          // get available rates from player if possible
          let rates = [0.25,0.5,0.75,1,1.25,1.5,1.75,2];
          try{
            if(state.player && typeof state.player.getAvailablePlaybackRates === 'function'){
              const avail = state.player.getAvailablePlaybackRates() || [];
              if(Array.isArray(avail) && avail.length) rates = avail.slice();
            }
          }catch(e){}
          // ensure 1 is included & unique sorted
          const set = {};
          rates.forEach(r=> set[Number(r)] = true);
          if(!set[1]) rates.push(1);
          rates = Object.keys(set).map(Number).sort((a,b)=>a-b);

          const curRate = (state.player && typeof state.player.getPlaybackRate === 'function') ? (state.player.getPlaybackRate()||1) : 1;

          rates.forEach(r=>{
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = 'vidu-playback-item' + (Math.abs(r - curRate) < 0.0001 ? ' active' : '');
            btn.setAttribute('role','menuitem');
            btn.textContent = formatRateLabel(r);
            btn.addEventListener('click', (ev)=>{
              ev.stopPropagation();
              try{
                if(state.player && typeof state.player.setPlaybackRate === 'function'){
                  state.player.setPlaybackRate(Number(r));
                }
                closePlaybackMenu();
                // update button title to reflect selection (for screen readers / tooltip)
                try{ playbackBtn.title = 'Playback speed: ' + formatRateLabel(r); playbackBtn.setAttribute('aria-label','Playback speed ' + formatRateLabel(r)); }catch(e){}
              }catch(e){ console.warn('setPlaybackRate err', e); }
            });
            playbackMenu.appendChild(btn);
          });

          // position it above the playbackBtn
          overlay.appendChild(playbackMenu);
          // compute left offset so it aligns with the button
          try{
            const overlayRect = overlay.getBoundingClientRect();
            const btnRect = playbackBtn.getBoundingClientRect();
            const left = Math.max(8, (btnRect.left - overlayRect.left) + (btnRect.width/2) - 44); // center menu above button (menu ~88px)
            playbackMenu.style.left = left + 'px';
            playbackMenu.style.bottom = (overlayRect.bottom - overlayRect.top + 8) + 'px'; // place above overlay bottom
          }catch(e){
            // fallback: right-align near the full button area
            playbackMenu.style.right = '72px';
            playbackMenu.style.bottom = '72px';
          }

          menuOpen = true;
          setTimeout(()=> document.addEventListener('click', docClickCloseHandler));
        }

        playbackBtn.addEventListener('click', (e)=>{
          e.stopPropagation();
          openPlaybackMenu();
        });

        // ensure menu closes when host is removed/destroyed
        const playbackMenuObserver = new MutationObserver(()=> {
          if(menuOpen && (!document.body.contains(playbackBtn) || !document.body.contains(overlay))) closePlaybackMenu();
        });
        playbackMenuObserver.observe(document.body, { childList: true, subtree: true });

        function setOverlayHidden(hidden){
          if(hidden){ overlay.classList.add('hidden'); ctrlBg.classList.add('hidden'); if(closeBtn) closeBtn.classList.add('hidden'); }
          else { overlay.classList.remove('hidden'); ctrlBg.classList.remove('hidden'); if(closeBtn) closeBtn.classList.remove('hidden'); }
        }

        // key handler (updated: central volume overlay usage)
        state.keyHandler = function(e){

              // ArrowUp / ArrowDown: volume control (+/- 5%)
              if(e.key === 'ArrowUp' || e.key === 'ArrowDown'){
                try{
                  if(!state.player) return;
                  e.preventDefault();
                  // YouTube API volume range is 0-100
                  let curVol = 100;
                  try{ curVol = (typeof state.player.getVolume === 'function') ? state.player.getVolume() : (state.lastVolume || 100); }catch(_){ curVol = state.lastVolume || 100; }
                  const delta = e.key === 'ArrowUp' ? 5 : -5;
                  let target = Math.max(0, Math.min(100, Math.round(curVol + delta)));
                  try{ if(typeof state.player.setVolume === 'function') state.player.setVolume(target); }catch(_){}
                  // MODIFIED: Update both local and global volume variables
                  state.lastVolume = target;
                  globalLastVolume = target;
                  // show modern center overlay (fresh logic)
                  try{ showVolumeOverlay(target); }catch(_){}
                  return;
                }catch(err){}
              }

          const active = document.activeElement;

        try{
          // Allow keyboard seeks even if the seek input is focused.
          // If user presses ArrowLeft/ArrowRight we seek -10s/+10s.
          if(e.key === 'ArrowLeft' || e.key === 'ArrowRight'){
            try{
              if(!state.player) return;
              // Prevent default scrolling
              e.preventDefault();
              const cur = (state.player.getCurrentTime && typeof state.player.getCurrentTime === 'function') ? state.player.getCurrentTime() : 0;
              const dur = (state.player.getDuration && typeof state.player.getDuration === 'function') ? state.player.getDuration() : null;
              const delta = e.key === 'ArrowRight' ? 10 : -10;
              let target = Math.max(0, cur + delta);
              if(dur !== null && isFinite(dur)) target = Math.min(target, dur);
              try{ state.player.seekTo(target, true); }catch(seekErr){ /* ignore */ }
              // update UI immediately if seekEl exists
              try{
                const seekEl2 = document.getElementById('vidu_seek') || document.querySelector('input[type=range]');
                if(seekEl2 && dur && isFinite(dur)){
                  seekEl2.value = (target / Math.max(1,dur)) * 100;
                  // update background visually if function exists
                  if(typeof updateSeekBackground === 'function') try{ updateSeekBackground(seekEl2); }catch(_){}
                }
              }catch(_){}
              return;
            }catch(err){}
          }
        }catch(err){}
          if(active){
            try{
              const tag = active.tagName || '';
              const atype = (active.getAttribute && active.getAttribute('type')) || '';
              const isRange = (tag.toUpperCase() === 'INPUT' && String(atype).toLowerCase() === 'range');
              const isSeek = (typeof seekEl !== 'undefined' && active === seekEl);
              // Allow spacebar to control playback when focus is on the seek slider (range) or the known seekEl.
              if(!isRange && !isSeek && (tag.toUpperCase() === 'INPUT' || tag.toUpperCase() === 'TEXTAREA' || active.isContentEditable)) return;
            }catch(err){ /* if inspection of active fails, fall back to conservative behavior */ }
          }
          const modal = document.getElementById('viewer');
          if(!modal || modal.classList.contains('hidden')) return;
          if(e.code === 'Space' || e.key === ' '){
            e.preventDefault();
            if(state.player){
              const st = state.player.getPlayerState ? state.player.getPlayerState() : -1;
              if(st === 1) try{ state.player.pauseVideo(); }catch(e){} else try{ state.player.playVideo(); }catch(e){}
            }
          } else if(e.code === 'KeyF' || e.key === 'f' || e.key === 'F'){
            e.preventDefault();
            toggleFullscreen();
          }
        };

        document.addEventListener('keydown', state.keyHandler);

        // seek handling
        seekEl.addEventListener('pointerdown', ()=> seekEl._drag=true, {passive:true});
        seekEl.addEventListener('pointerup', ()=>{ seekEl._drag=false; if(!state.player) return; const dur = state.player.getDuration ? state.player.getDuration() : 0; if(dur) state.player.seekTo(dur * (parseFloat(seekEl.value)/100), true); }, {passive:true});
        seekEl.addEventListener('input', ()=>{ if(seekEl._drag && state.player){ const dur = state.player.getDuration ? state.player.getDuration() : 0; if(dur) curEl.textContent = fmtTime(Math.floor(dur * (parseFloat(seekEl.value)/100))); updateSeekBackground(seekEl); } }, {passive:true});

        function updateSeekBackground(el){
          try{ const v = Math.max(0, Math.min(100, parseFloat(el.value) || 0)); el.style.background = `linear-gradient(90deg, #39ff14 ${v}%, rgba(255,255,255,0.06) ${v}%)`; }catch(e){}
        }
        updateSeekBackground(seekEl);

        // play/pause UI
        playBtn.addEventListener('click', ()=> {
          if(!state.player) return;
          let st = -1;
          try{ st = state.player.getPlayerState ? state.player.getPlayerState() : -1; }catch(e){}
          const wantPlay = !(st === 1);
          state.desiredPlaying = wantPlay;
          playBtn.innerHTML = wantPlay ? pauseSVG() : playSVG();
          try{ if(wantPlay){ if(typeof state.player.playVideo === 'function') state.player.playVideo(); } else { if(typeof state.player.pauseVideo === 'function') state.player.pauseVideo(); } }catch(e){ console.warn('play/pause toggle err', e); }
          resetInactivityTimer();
        });

        function onFSChange(){
          const fs = document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement || null;
          const isOurFullscreen = !!(fs && (fs === host || host.contains(fs) || (fs.contains && fs.contains(host))));
          const fullBtnLocal = document.getElementById('vidu_fullbtn');

          if(isOurFullscreen){
            // entering fullscreen: save inline styles and adjust to viewport
            if(fullBtnLocal) fullBtnLocal.innerHTML = exitFullscreenSVG(); // Change to exit icon
            try{
              if(!saved.stored){
                saved.host.position = host.style.position || '';
                saved.host.top = host.style.top || '';
                saved.host.left = host.style.left || '';
                saved.host.width = host.style.width || '';
                saved.host.height = host.style.height || '';
                saved.host.zIndex = host.style.zIndex || '';
                saved.host.borderRadius = host.style.borderRadius || '';

                saved.mount.height = mount.style.height || '';
                saved.mount.width = mount.style.width || '';
                saved.mount.maxHeight = mount.style.maxHeight || '';
                saved.mount.maxWidth = mount.style.maxWidth || '';

                const ifr = host.querySelector('iframe');
                if(ifr){
                  saved.iframe.height = ifr.style.height || '';
                  saved.iframe.width = ifr.style.width || '';
                  saved.iframe.pointerEvents = ifr.style.pointerEvents || '';
                  saved.iframe.maxHeight = ifr.style.maxHeight || '';
                  saved.iframe.maxWidth = ifr.style.maxWidth || '';
                } else {
                  saved.iframe = {};
                }

                saved.stored = true;
              }

              host.style.position = 'fixed';
              host.style.top = '0';
              host.style.left = '0';
              host.style.width = '100vw';
              host.style.height = '100vh';
              host.style.zIndex = '2147483647';
              host.style.borderRadius = '0';

              mount.style.width = '100%';
              mount.style.height = '100%';
              mount.style.maxHeight = 'none';
              mount.style.maxWidth = 'none';

              const ifr = host.querySelector('iframe');
              if(ifr){
                ifr.style.width = '100%';
                ifr.style.height = '100%';
                ifr.style.maxHeight = 'none';
                ifr.style.maxWidth = 'none';
                ifr.style.pointerEvents = 'auto';
              }
            }catch(e){}

            ctrlBg.classList.remove('hidden');
            overlay.classList.remove('hidden');
            if(closeBtn) closeBtn.classList.remove('hidden');

            // attach resize handler while in fullscreen so host keeps viewport size
            if(!state.fsResizeHandler){
              state.fsResizeHandler = savedResizeHandler;
              window.addEventListener('resize', state.fsResizeHandler);
            }
          } else {
            // exiting fullscreen: restore saved inline styles
            if(fullBtnLocal) fullBtnLocal.innerHTML = enterFullscreenSVG(); // Change back to enter icon
            try{
              if(saved.stored){
                host.style.position = saved.host.position;
                host.style.top = saved.host.top;
                host.style.left = saved.host.left;
                host.style.width = saved.host.width;
                host.style.height = saved.host.height;
                host.style.zIndex = saved.host.zIndex;
                host.style.borderRadius = saved.host.borderRadius;

                mount.style.height = saved.mount.height;
                mount.style.width = saved.mount.width;
                mount.style.maxHeight = saved.mount.maxHeight;
                mount.style.maxWidth = saved.mount.maxWidth;

                const ifr = host.querySelector('iframe');
                if(ifr){
                  ifr.style.height = saved.iframe.height;
                  ifr.style.width = saved.iframe.width;
                  ifr.style.pointerEvents = saved.iframe.pointerEvents;
                  ifr.style.maxHeight = saved.iframe.maxHeight;
                  ifr.style.maxWidth = saved.iframe.maxWidth;
                }
                saved.stored = false;
              } else {
                // fallback restore: ensure mount has sensible defaults
                try{ mount.style.height = '100%'; mount.style.width = '100%'; }catch(e){}
                try{ const ifr = host.querySelector('iframe'); if(ifr) ifr.style.pointerEvents = 'none'; }catch(e){}
              }
            }catch(e){}

            if(state.fsResizeHandler){
              window.removeEventListener('resize', state.fsResizeHandler);
              state.fsResizeHandler = null;
            }

            if(overlay.classList.contains('hidden')){
              ctrlBg.classList.add('hidden');
              if(closeBtn) closeBtn.classList.add('hidden');
            } else {
              ctrlBg.classList.remove('hidden');
              if(closeBtn) closeBtn.classList.remove('hidden');
            }
          }
        }

        state.fsListener = onFSChange;
        document.addEventListener('fullscreenchange', state.fsListener);
        document.addEventListener('webkitfullscreenchange', state.fsListener);
        document.addEventListener('mozfullscreenchange', state.fsListener);
        document.addEventListener('MSFullscreenChange', state.fsListener);

        function resetInactivityTimer(){
          state.lastActivity = Date.now();
          setOverlayHidden(false);
          if(state.inactivityTimer){ clearTimeout(state.inactivityTimer); state.inactivityTimer = null; }
          // MODIFIED: Inactivity timeout changed from 5000ms to 3000ms.
          state.inactivityTimer = setTimeout(()=>{ 
            try{
              const st = state.player && typeof state.player.getPlayerState === 'function' ? state.player.getPlayerState() : -1;
              if(st === 1 || st === 3 || st === -1 || st === 0 || st === 5){
                setOverlayHidden(true);
              }
            }catch(e){}
          }, 3000);
        }

        function attachActivityListeners(){
          try{ ['mousemove','pointermove','touchstart','touchmove','keydown','mousedown'].forEach(ev=>{ host.addEventListener(ev, resetInactivityTimer, {passive:true}); document.addEventListener(ev, resetInactivityTimer, {passive:true}); }); }catch(e){}
        }
        attachActivityListeners();

        // instantiate YT.Player
        return new Promise((resolve,reject)=>{
          try{
            state.player = new YT.Player(mount.id, {
              videoId: videoId,
              width: '100%',
              height: '100%',
              playerVars: { controls: 0, disablekb: 1, rel: 0, modestbranding: 1, playsinline: 1, iv_load_policy: 3, origin: location.origin },
              events: {
                onReady: function(evt){
                  disableIframeClicks(host);

                  // ensure loading overlay visible until playback begins
                  try{ const ld = document.getElementById('vidu_loading'); if(ld){ ld.classList.remove('hidden'); ld.style.display='flex'; } }catch(e){}

                  try{
                    if(typeof evt.target.setVolume === 'function'){
                      // MODIFIED: Use the global volume variable to set volume for the new player.
                      const v = Math.max(0, Math.min(100, globalLastVolume));
                      evt.target.setVolume(v);
                      state.lastVolume = v; // Sync local state
                      if(v === 0 && typeof evt.target.mute === 'function') evt.target.mute();
                      else if(v > 0 && typeof evt.target.unMute === 'function') evt.target.unMute();
                      // show overlay initial volume for clarity
                      try{ showVolumeOverlay(v); }catch(_){}
                    }
                  }catch(e){}

                  // explicitly set default (auto) so YouTube chooses the best quality
                  try{
                    if(typeof evt.target.setPlaybackQuality === 'function'){
                      evt.target.setPlaybackQuality('default');
                      setTimeout(()=> { try{ evt.target.setPlaybackQuality('default'); }catch(e){} }, 800);
                      setTimeout(()=> { try{ evt.target.setPlaybackQuality('default'); }catch(e){} }, 2200);
                    }
                  }catch(e){}

                  try{ evt.target.playVideo(); }catch(e){}

                  if(state.updateInterval) clearInterval(state.updateInterval);
                  state.updateInterval = setInterval(()=>{
                    try{
                      if(!state.player) return;
                      const dur = state.player.getDuration ? state.player.getDuration() : 0;
                      const cur = state.player.getCurrentTime ? state.player.getCurrentTime() : 0;
                      const curElLocal = document.getElementById('vidu_cur');
                      const durElLocal = document.getElementById('vidu_dur');
                      if(curElLocal) curElLocal.textContent = fmtTime(Math.floor(cur));
                      if(durElLocal) durElLocal.textContent = (dur && isFinite(dur)) ? fmtTime(Math.floor(dur)) : fmtTime(0);
                      if(!seekEl._drag && dur && isFinite(dur)) {
                        seekEl.value = (cur / Math.max(1,dur)) * 100;
                        updateSeekBackground(seekEl);
                      }
                      const st = state.player.getPlayerState ? state.player.getPlayerState() : -1;
                      if(state.desiredPlaying !== null){
                        if(state.desiredPlaying && st !== 1) try{ state.player.playVideo(); }catch(e){}
                        else if(!state.desiredPlaying && st === 1) try{ state.player.pauseVideo(); }catch(e){}
                      }
                      const currentIcon = (st === 1) ? pauseSVG() : playSVG();
                      if(Date.now() - state.lastActivity > 300) playBtn.innerHTML = currentIcon;
                      else setTimeout(()=> { try{ const check = state.player.getPlayerState ? state.player.getPlayerState() : -1; if(check === 1) playBtn.innerHTML = pauseSVG(); else playBtn.innerHTML = playSVG(); }catch(e){} }, 600);
                    }catch(e){}
                  }, 160);

                  if(state.mo) state.mo.disconnect();
                  state.mo = new MutationObserver(()=> disableIframeClicks(host));
                  state.mo.observe(host, { childList:true, subtree:true });

                  resetInactivityTimer();

                  // set default playback button title / aria attributes to current rate
                  try{
                    const curRate = (state.player && typeof state.player.getPlaybackRate === 'function') ? (state.player.getPlaybackRate() || 1) : 1;
                    try{ playbackBtn.title = 'Playback speed: ' + (Math.round(curRate*100)/100) + '×'; playbackBtn.setAttribute('aria-label','Playback speed ' + (Math.round(curRate*100)/100) + '×'); }catch(e){}
                  }catch(e){}

                  resolve(state.player);
                },
                onStateChange: function(e){
                  try{
                    // hide loading overlay when state becomes PLAYING (1)
                    if(e && e.data === 1){
                      try{ const ld = document.getElementById('vidu_loading') || document.querySelector('.vidu-loading'); if(ld){ try{ ld.classList.add('hidden'); ld.style.display='none'; }catch(e){} } }catch(err){}
                    }
                    // Keep internal desiredPlaying in sync with actual player state so user actions win.
                    try{
                      if(typeof state !== 'undefined' && state !== null && e && typeof e.data === 'number'){
                        if(e.data === 1){ /* PLAYING */ state.desiredPlaying = true; }
                        else if(e.data === 2 || e.data === 0){ /* PAUSED or ENDED */ state.desiredPlaying = false; }
                        // For buffering (3), unstarted (-1) or cued (5) we don't change desiredPlaying here.
                      }
                    }catch(syncErr){ /* swallow sync errors */ }
                  }catch(err){}
                },
                onError: function(err){ console.error('YT player error', err); try{ const ld = document.getElementById('vidu_loading'); if(ld){ ld.classList.add('hidden'); ld.style.display='none'; } }catch(_){} reject(err); }
              }
            });
          }catch(err){ reject(err || new Error('YT player creation failed')); }
        });
      }

      function destroyPlayer(){
        try{
          if(state.updateInterval){ clearInterval(state.updateInterval); state.updateInterval = null; }
          if(state.keyHandler){ document.removeEventListener('keydown', state.keyHandler); state.keyHandler = null; }
          if(state.player){ try{ state.player.destroy(); }catch(e){} state.player = null; }
          if(state.mo){ try{ state.mo.disconnect(); }catch(e){} state.mo = null; }
          if(state.fsResizeHandler){ window.removeEventListener('resize', state.fsResizeHandler); state.fsResizeHandler = null; }
          if(state.fsListener){ document.removeEventListener('fullscreenchange', state.fsListener); document.removeEventListener('webkitfullscreenchange', state.fsListener); document.removeEventListener('mozfullscreenchange', state.fsListener); document.removeEventListener('MSFullscreenChange', state.fsListener); state.fsListener = null; }
          if(state.inactivityTimer){ clearTimeout(state.inactivityTimer); state.inactivityTimer = null; }
          if(state.volumeHideTimer){ clearTimeout(state.volumeHideTimer); state.volumeHideTimer = null; }
          if(state.host){
            try{ ['mousemove','pointermove','touchstart','touchmove','keydown','mousedown'].forEach(ev=>{ state.host.removeEventListener(ev, resetInactivityTimer); document.removeEventListener(ev, resetInactivityTimer); }); }catch(e){}
          }
          if(state.host){ try{ state.host.remove(); }catch(e){} state.host = null; state.mount = null; }
        }catch(e){ console.warn('destroyPlayer err', e); }
      }

      // expose
      window.showViduPlayer = async function(videoId, mountRootId='player-wrap'){
        return createYTPlayer(videoId, mountRootId);
      };
      window.destroyViduPlayer = function(){ destroyPlayer(); const w = document.getElementById('player-wrap'); if(w) w.innerHTML = ''; };

      window.addEventListener('beforeunload', ()=> { try{ window.destroyViduPlayer(); }catch(e){} }, {passive:true});

      // helper used in destroyPlayer closure
      function resetInactivityTimer(){ /* placeholder for removeEventListener binding */ }
    })(); // end playerModule

    /* ---------- Playlist fetcher (YouTube Data API) ---------- */
    async function fetchPlaylistVideos(playlistId){
      if(!YT_API_KEY || YT_API_KEY === 'YOUR_API_KEY_HERE') throw new Error('No API key configured.');
      const results = []; let pageToken = '';
      do {
        const url = `https://www.googleapis.com/youtube/v3/playlistItems?part=snippet&maxResults=50&playlistId=${encodeURIComponent(playlistId)}&key=${encodeURIComponent(YT_API_KEY)}` + (pageToken?`&pageToken=${pageToken}`:'');
        const res = await fetch(url);
        if(!res.ok){ const txt = await res.text().catch(()=>null); throw new Error('YouTube API error: '+res.status+' '+res.statusText+' '+(txt||'')); }
        const data = await res.json();
        (data.items||[]).forEach(it => {
          const sn = it.snippet || {};
          if(sn.resourceId && sn.resourceId.videoId){
            const thumb = (sn.thumbnails && (sn.thumbnails.high||sn.thumbnails.medium||sn.thumbnails.default))||{};
            results.push({ videoId: sn.resourceId.videoId, title: sn.title||'Untitled', thumb: thumb.url||`https://img.youtube.com/vi/${sn.resourceId.videoId}/hqdefault.jpg` });
          }
        });
        pageToken = data.nextPageToken || '';
      } while(pageToken);
      return results;
    }

    /* ---------- show playlist (legacy) - kept but not used for initial playlist open ---------- */
    async function showPlaylistInsideViewer(item){
      // This function is left intact for backward compatibility but we no longer auto-play the first video.
      // Current logic: show player + playlist in viewer when explicitly required.
      const rawId = normalizeIdFromB64(item.idB64);
      const playlistId = rawId.split('&')[0];
      const iframeWrap = document.getElementById('iframe-wrap');
      iframeWrap.innerHTML = '';

      // ensure playlist area is visible and set split sizes
      const playlistContainer = document.getElementById('viewer-playlist');
      playlistContainer.style.display = '';
      // set explicit flex split: player top 62%, playlist bottom 38%
      iframeWrap.style.flex = '0 0 62%';
      playlistContainer.style.flex = '0 0 38%';
      playlistContainer.innerHTML = '';
      playlistContainer.scrollTop = 0;

      // create mount inside the iframe-wrap for the advanced player
      const mountRoot = document.createElement('div'); mountRoot.id = 'player-wrap'; mountRoot.style.width='100%'; mountRoot.style.height='100%';
      iframeWrap.appendChild(mountRoot);

      // update now playing title (temporary while loading)
      const nowPlayingEl = document.getElementById('now-playing-title');
      if(nowPlayingEl) nowPlayingEl.textContent = item.title || 'Playlist';

      try{
        const videos = await fetchPlaylistVideos(playlistId);
        if(!videos.length) throw new Error('No videos found or playlist is private.');

        // populate playlistContainer (below player)
        playlistContainer.innerHTML = '';
        videos.forEach(v=>{
          const li = document.createElement('div');
          li.className = 'list-item';
          li.setAttribute('role','button');
          li.tabIndex = 0;
          li.innerHTML = `<img src="${escapeHtml(v.thumb)}" alt="${escapeHtml(v.title)}" /><div class="playlist-meta"><div class="playlist-title">${escapeHtml(v.title)}</div><div class="playlist-sub">Click to play</div></div>`;
          function playThis(){
            // update now playing title
            const np = document.getElementById('now-playing-title');
            if(np) np.textContent = v.title || 'Now playing';
            if(window.showViduPlayer){
              try{ window.destroyViduPlayer(); }catch(e){}
              mountRoot.innerHTML = `<div style="padding:18px;color:#ddd;">Loading advanced player.</div>`;
              window.showViduPlayer(v.videoId, 'player-wrap').catch(err=>{
                mountRoot.innerHTML = '';
                const errBlock = document.createElement('div');
                errBlock.style.padding = '18px'; errBlock.style.color = '#ffdede';
                errBlock.innerHTML = `<div style="font-weight:800;margin-bottom:10px;">Failed to load advanced player</div><div style="margin-bottom:10px;">${escapeHtml(err && err.message ? err.message : String(err))}</div>`;
                const retryBtn = document.createElement('button');
                retryBtn.className = 'btn'; retryBtn.textContent = 'Retry Advanced Player';
                retryBtn.addEventListener('click', ()=> {
                  resetYTLoader();
                  mountRoot.innerHTML = `<div style="padding:18px;color:#ddd;">Retrying advanced player...</div>`;
                  window.showViduPlayer(v.videoId, 'player-wrap').catch(e2=>{
                    mountRoot.innerHTML = '';
                    errBlock.innerHTML = `<div style="font-weight:800;margin-bottom:10px;">Failed to load advanced player</div><div style="margin-bottom:10px;">${escapeHtml(e2 && e2.message ? e2.message : String(e2))}</div>`;
                    mountRoot.appendChild(errBlock); mountRoot.appendChild(retryBtn);
                  });
                });
                mountRoot.appendChild(errBlock); mountRoot.appendChild(retryBtn);
              });
            }
          }
          li.addEventListener('click', playThis);
          li.addEventListener('keydown', (e)=> { if(e.key === 'Enter' || e.key === ' ') { e.preventDefault(); playThis(); } });
          playlistContainer.appendChild(li);
        });

        // Do not autoplay first video here anymore. User must click item to play (or use separate flow).
      }catch(err){
        iframeWrap.innerHTML = '';
        playlistContainer.innerHTML = '';
        const errBlock = document.createElement('div');
        errBlock.style.padding = '18px'; errBlock.style.color = '#ffdede';
        errBlock.innerHTML = `<div style="font-weight:800;margin-bottom:10px;">Failed to load playlist</div><div>${escapeHtml(err && err.message ? err.message : String(err))}</div>`;
        iframeWrap.appendChild(errBlock);
      }
    }

    /* ---------- open viewer helper (decides video vs playlist) ---------- */
    function openViewer(item){
      try{
        const viewer = document.getElementById('viewer');
        if(!viewer) return;
        const iframeWrap = document.getElementById('iframe-wrap');
        iframeWrap.innerHTML = '';
        // update now playing title
        const np = document.getElementById('now-playing-title');
        if(np) np.textContent = item.title || 'Now playing';

        // show viewer
        viewer.classList.remove('hidden');
        viewer.setAttribute('aria-hidden','false');
        document.body.style.overflow = 'hidden';

        if(item.type === 'playlist'){
          // fallback legacy: if somehow asked to show playlist inside viewer, use legacy method
          showPlaylistInsideViewer(item);
        } else {
          // single video
          const mountRoot = document.createElement('div'); mountRoot.id = 'player-wrap'; mountRoot.style.width='100%'; mountRoot.style.height='100%';
          iframeWrap.appendChild(mountRoot);
          window.showViduPlayer(normalizeIdFromB64(item.idB64), 'player-wrap').catch(err=>{
            mountRoot.innerHTML = `<div style="padding:18px;color:#ffdede;">${escapeHtml(err && err.message ? err.message : String(err))}</div>`;
          });
        }
      }catch(e){ console.warn('openViewer err', e); }
    }

    // viewer close (header close button)
    document.getElementById('viewer-close').addEventListener('click', ()=>{
      try{
        const v = document.getElementById('viewer'); if(v){ v.classList.add('hidden'); v.setAttribute('aria-hidden','true'); }
        if(window.destroyViduPlayer) window.destroyViduPlayer();
        const wrap = document.getElementById('iframe-wrap'); if(wrap) wrap.innerHTML = '';
        document.body.style.overflow = '';
        
        // MODIFIED: If we had a last opened playlist, reopen it.
        if(lastOpenedPlaylistItem){
          // tiny delay so close animations finish
          setTimeout(()=> openPlaylistPopup(lastOpenedPlaylistItem), 120);
        }
        
      }catch(e){}
    });

    // Wrap existing destroy function so any programmatic destroys also handle state correctly
    (function wrapDestroy(){
      const orig = window.destroyViduPlayer;
      if(typeof orig === 'function'){
        window.destroyViduPlayer = function(){
          try{ orig(); }catch(e){ console.warn('wrapped destroy error', e); }
          try{
            // if viewer already hidden, ensure it's hidden
            const v = document.getElementById('viewer'); if(v){ v.classList.add('hidden'); v.setAttribute('aria-hidden','true'); }
            const wrap = document.getElementById('iframe-wrap'); if(wrap) wrap.innerHTML = '';
            document.body.style.overflow = '';
          }catch(e){}

          // MODIFIED: If we had a last opened playlist, reopen it.
          if(lastOpenedPlaylistItem){
            setTimeout(()=> openPlaylistPopup(lastOpenedPlaylistItem), 120);
          }

        };
      } else {
        // if not defined yet, polyfill a small wrapper to be safe: try again later
        setTimeout(wrapDestroy, 400);
      }
    })();

    // initial render
    buildTiles();

    // expose openViewer globally for other use
    window.openViewer = openViewer;

    /* ===== MODIFIED: Login & access UI wiring ===== */
    const loginBtnTop = document.getElementById('login-btn-top');
    const loginModal = document.getElementById('login-modal');
    const loginClose = document.getElementById('login-close');
    const loginUsernameInput = document.getElementById('login-username');
    const loginPasswordInput = document.getElementById('login-password');
    const loginSubmit = document.getElementById('login-submit');
    const loginError = document.getElementById('login-error');
    
    // Get all modals and their buttons
    const accessModal = document.getElementById('access-modal');
    const accessClose = document.getElementById('access-close');
    const accessRequestBtn = document.getElementById('access-request-btn');

    const noAccessModal = document.getElementById('no-access-modal');
    const noAccessClose = document.getElementById('no-access-close');
    const noAccessRequestBtn = document.getElementById('no-access-request-btn');

    const requestAccessLink = 'https://wa.me/254703255099';

    // Updated login function to use the permission system
    function handleLogin() {
        const username = loginUsernameInput.value.trim();
        const password = loginPasswordInput.value.trim();
        loginError.textContent = '';

        const userAccount = userPermissions[username];

        if (userAccount && userAccount.password === password) {
            // LOGIN SUCCESSFUL
            currentUser = {
                username: username,
                permissions: userAccount.access || []
            };
            alert('✅ Logged in successfully! [VIDU]');
            closeModal(loginModal);
            loginBtnTop.textContent = `✅ Logged In as ${username}`;
            loginBtnTop.disabled = true;
        } else {
            loginError.textContent = 'Invalid username or password.';
        }
    }

    // Login modal event listeners
    loginBtnTop.addEventListener('click', () => {
        loginError.textContent = '';
        loginUsernameInput.value = '';
        loginPasswordInput.value = '';
        showModal(loginModal);
        setTimeout(() => loginUsernameInput.focus(), 120);
    });
    loginClose.addEventListener('click', () => closeModal(loginModal));
    loginModal.addEventListener('click', (e) => { if (e.target === loginModal) closeModal(loginModal); });
    loginSubmit.addEventListener('click', handleLogin);
    loginPasswordInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') handleLogin(); });

    // "Login to access" modal event listeners
    accessClose.addEventListener('click', () => closeModal(accessModal));
    accessModal.addEventListener('click', (e) => { if (e.target === accessModal) closeModal(accessModal); });
    accessRequestBtn.addEventListener('click', () => window.open(requestAccessLink, '_blank'));

    // "No access" modal event listeners
    noAccessClose.addEventListener('click', () => closeModal(noAccessModal));
    noAccessModal.addEventListener('click', (e) => { if (e.target === noAccessModal) closeModal(noAccessModal); });
    noAccessRequestBtn.addEventListener('click', () => window.open(requestAccessLink, '_blank'));

  })();
  </script>
</body>
</html>

